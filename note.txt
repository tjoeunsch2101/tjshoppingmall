20240424

 project 초기 설정
 
 front-end 초기 설정
 templates 에
 fragments > header, footer
 layouts > layout
 
 HomeController 작성해서
 project 실행함 <- main 화면이 나타남
 
 Member Entity class 작성
 Role Enum 작성 : USER, ADMIN
 MemberFormDto 작성
 
 Order Entity class 작성
 OrderStatus Enum 작성
 OrderItem Entity class 작성
 Item Entity class 작성
 ItemSellStatus Enum 작성
 
 ItemFormDto class 작성
 ItemImgDto class 작성
 ItemImg Entity class 작성
 
 MemberRepository 작성
 MemberService 작성
 MemberController 작성
 
 build.gradle 에
 implementation 'org.springframework.boot:spring-boot-starter-validation'
 추가하고
 MemberFormDto 에
 validation annotation 추가
 
 
 memberLoginForm.html 작성함
 MemberController 에 
 @GetMapping("/login") 작성
 @GetMapping("/login/error") 작성
   ㄴ loginErrorMsg 를 requestScope 에 올려서
      memberLoginForm.html 에서 
      <p th:if="${loginErrorMsg}" 으로 처리함
 
 
 header.html 에
 xmlns:sec="http://www.thymeleaf.org/extras/spring-security"
 추가하고
 sec:authorize="hasAnyAuthority('ROLE_ADMIN')
 을 설정해서 관리자 권한으로 로그인 했을 때만 나타나는 메뉴 설정
 sec:authorize="isAuthenticated()
 을 설정해서 로그인 했을 때만 나타나는 메뉴 설정
 sec:authorize="isAnonymous()
 을 설정해서 로그아웃 상태에서 나타나는 메뉴 설정
   ㄴ 이 설정들은
      SecutiryConfig 에서 설정한
      페이지에 대한 접근권한 설정 부분 과 연동되어서 작동함 
 

 MemberController 에 
 @GetMapping("/logout") 작성해서
   ㄴ session 정보 삭제함
 로그아웃 버튼 활성화함
 sec:authorize="isAnonymous() 
 가 적용되는 상태가 됨
 
 
 관리자가 아닌데 관리자 권한으로 접근 가능한 url 에 
 접속을 시도하는 경우 처리하기
 SecutiryConfig 에 
 http.exceptionHandling(exception -> exception
   .accessDeniedHandler(new CustomAccessDeniedHandler())); 추가하고
 CustomAccessDeniedHandler 클래스 작성하고
   ㄴ response.sendRedirect("/members/login/accessDenied");
 MemberController 에서   "/members/login/accessDenied" url pattern 을 받는 메소드 작성
   ㄴ @GetMapping("/login/accessDenied")
 
  
  Cart 와 Item 은 ManyToMany 관계
  
              연결테이블
 Cart  <---   CartItem   --->   Item
 cart         cart_item         item
 부모         자식              부모
 참조키       외래키            참조키
 One          Many              One
 
 
 Cart Entity class 작성
  ㄴ Member Entity 의 member_id 를 외래키로 함
 
 
  CartItem Entity class 작성
  ㄴ Cart Entity 의 cart_id 를 외래키로 함
  ㄴ Item Entity 의 item_id 를 외래키로 함
 
 
 
 Order Entity class 와 
 OrderItem Entity class 를 연관관계(양방향)로 설정함
 
 
 - 양방향관계 설정 - 
  
 OrderItem
 @ManyToOne(fetch=FetchType.LAZY)
	@JoinColumn(name="order_id")
	private Order order;
 
 Order
 @OneToMany(fetch=FetchType.LAZY, mappedBy = "order", 
		    cascade=CascadeType.ALL, orphanRemoval=true)
 private List<OrderItem> orderItems = new ArrayList<>();
	
 
 ------------------------------------------------------------------
 
 20240425
 
 Auditing 기능 설정하기
 
 AuditorAware 인터페이스를 구현한 AuditorAwareImpl 클래스 작성하기
 AuditConfig 클래스 작성
 
 
 BasicTimeEntity 클래스 작성
 BasicEntity 클래스 작성
   ㄴ Entity 클래스들에 있는 공통 멤버변수들을
      작성해서 상속하게 함
      
      BasicTimeEntity
      regTime, updateTime
      
      BasicEntity
      createdBy, modifiedBy

      
spring.jpa.hibernate.ddl-auto=create
로 설정하고 project 를 다시 실행함
dbeaver 에서 각 table 에 상속받은 컬럼들이
생성되었는지 확인하기

------------------------------------------------------------------
 

 상품 등록 / 조회
 
 ItemImg Entity 작성하기
 
 ItemImg Entity (item_img)  <-- Item Entity (item) 의 
                                item_id (primary key) 를 
                                foreign key 로 가져옴
  id                              
  imgName    업로드하는 이미지 파일이름 , 
  oriImgName 원본 이미지 파일이름,
  imgUrl     이미지 경로,
  repimgYn   대표 이미지인지 여부
  
  Item item  <-- item table 에서는 item_id 라는 컬럼이 됨
                                   (foreign key)
    @ManyToOne(fetch=FetchType.LAZY)
	@JoinColumn(name="item_id")  <--  item_id 컬럼이름
	private Item item;
	          ㄴ   alter table if exists item_img                                                   reference key(참조키)
			       add constraint FKdd5u08y3ap4c46ayrqjf8g88m foreign key (item_id) references item (item_id)
	                                 foreign key 이름                       ㄴ item_img 테이블에서
	                                                                           foreign key 로 지정한
	                                                                           컬럼이름             
	                                 references item (item_id) 
                                                테이블  컬럼
                                                item 테이블의 item_id 컬럼을 reference 한다는 의미
                                                                             참조 : 값을 가져와서 사용한다는 의미                            
    @ManyToOne(fetch=FetchType.LAZY)
      ㄴ 상품 엔티티(Item Entity class)와 다대일(ManyToOne) 단방향 관계로 매핑함
         지연 로딩(FetchType.LAZY)을 설정하여 
         매핑된 상품 엔티티(Item Entity class) 정보가 필요할 경우
         데이터를 조회함 (상품 엔티티(Item Entity class) 메모리에 올림)
         
    updateItemImg(String imgName, String oriImgName, String imgUrl) 메소드 작성
      ㄴ 업데이트할 이미지 파일이름, 원본 이미지 파일이름, 이미지 경로를 
         파라미터로 입력 받아서 이미지 정보를 업데이트하는 메소드
  
  
  
  ItemImgDto 작성하기
  
  properties 에
  implementation 'org.modelmapper:modelmapper:3.2.0'
  추가하고
  ModelMapper 사용하기
  
  private static ModelMapper modelMapper = new ModelMapper();
   ㄴ 멤버 변수로 ModelMapper 객체를 추가
  
  public static ItemImgDto of(ItemImg ItemImg) 메소드
   ㄴ ItemImg 엔티티 객체를 파라미터로 받아서 
      ItemImg 객체의 자료형과 멤버변수의 이름이 같을 때 
      ItemImgDto로 값을 복사해서 반환함. 
      static 메소드로 선언해 ItemImgDto객체를 
      생성하지 않아도 호출할 수 있도록 함.
  
------------------------------------------------------------------
   
  Spring Container 에
  ModelMapper 객체(Bean) 로 등록하려면
  @Configuration
  MapperConfig 클래스에
  modelMapper() 메소드를 작성함
    ㄴ @Autowired
	   private ModelMapper modelMapper;
	     ㄴ 이와 같이 객체를 불러와서 
	        사용할 수 있음
	        
 static 으로 사용하려면 @Autowired 를 하지 않고
 객체를 생성해서 할당한 후 사용함	        
 private static ModelMapper modelMapper = new ModelMapper();
------------------------------------------------------------------
 
  
 ItemFormDto 작성
   ㄴ 상품 등록 페이지에서
      (item 폴더의 itemForm.html )
      등록할 때 입력한 상품 정보와
      상품 이미지 정보를 저장하는 DTO
      
 validation annotation 추가
 
 
 private List<ItemImgDto> itemImgDtoList = new ArrayList<>();
   ㄴ 상품 저장 후 수정할 때 상품 이미지 정보를 저장하는 리스트
   
 private List<Long> itemImgIds = new ArrayList<>();
   ㄴ   상품의 이미지 아이디를 저장하는 리스트
		상품 등록 시에는 아직 상품의 이미지를 저장하지 않았기 때문에
		아무 값도 들어가 있지 않고 수정 시에 이미지 아이디를 저장함
 
  public Item createItem() 
  public static ItemFormDto entityToDto(Item item)
    ㄴ modelMapper를 이용하여 엔티티 객체와 DTO 객체 간의 데이터를 복사하여 
       복사한 객체를 반환해주는 메소드
  
  
 ItemController 작성
 ItemService  작성
 ItemRepository 작성
 ItemImgRepository 작성
 ItemImgService 작성
 ItemRepositoryCustom 작성
 ItemRepositoryCustomImpl 작성
 
 item 폴더에 itemForm.html 작성
 
 
 let errorMsg = [[${errorMsg}]];
         if(errorMsg != null){
             alert(errorMsg);
         }
         
 상품 등록 시 실패 메시지를 받아서 상품 등록 페이지가 나타날 때
 alert를 통해서 상품 등록 실패 이유를 출력함
 
 if(fileExtension != "jpg" && fileExtension != "jpeg" && 
    fileExtension != "gif" && fileExtension != "png" && fileExtension != "bmp")
    
    ㄴ 이미지 파일의 확장자가 jpg jpeg gif png bmp 인 경우에만
       이미지 파일 등록이 가능함
    
  // 이미지 파일인 경우
  $(this).siblings(".custom-file-label").html(fileName);
    	ㄴ 	클래스가 custom-file-label 인 element 가 화면에 나오게 함
    			
  enctype="multipart/form-data	
    			ㄴ 파일 전송시 enctype 설정
    			   이 설정은 method(전송방식) 가 post 인 경우에만 사용 가능함
    			
<select th:field="*{itemSellStatus}" class="custom-select">
  <option value="SELL">판매중</option>
  <option value="SOLD_OUT">품절</option>
</select>
 ㄴ 등록 상품 상태를 설정하는 부분  select tag
 
 <div th:if ="${#lists.isEmpty(itemFormDto.itemImgDtoList)}" > 
   ㄴ 상품 이미지 정보를 담고 있는 리스트가 비어 있다면 상품을 등록함
 
<div class="form-group" th:each="number: ${#numbers.sequence(1, 5)} ">
    ㄴ thymeleaf 의 유틸리티 객체 #numbers.sequence(start, end)를 이용하면 
        start부터 end까지 반복 처리를 함
       상품 등록 시 이미지의 개수를 최대 5개로 함 
        number에는 1부터 5까지 숫자가 할당됨
 
 project 실행  ...  OK 
 
 <div th:if= "${not #lists.isEmpty(itemFormDto.itemImgDtoList)}" >
   ㄴ 상품 이미지 정보를 담고 있는 리스트가 비어 있지 않다면 상품을 수정함
 
 <input type="hidden" name="itemImgIds" th:value="${itemImgDto.id}"/>
   ㄴ 상품 수정 시 어떤 이미지가 수정됐는지를 알기 위해서 
      상품 이미지의 아이디를 hidden type 으로 설정함
 
 not #strings.isEmpty(itemImgDto.oriImgName)} ? ${itemImgDto.oriImgName}  : '상품이미지' + ${status.index+1}"
   ㄴ thymeleaf 의 유틸리티 객체인 #string.isEmpty(string)을 이용하여 
		저장된 이미지 정보가 있다면 파일의 이름을 출력하고,
		 없다면 ‘상품 이미지+번호’를 출력함 
 
${#strings.isEmpty(itemFormDto.id)}
 
 <div th:if="${#strings.isEmpty(itemFormDto.id)}" style="text-align: center;">
    <button th:formaction="@{/admin/item/new}" type="submit" class="btn btn-primary">상품등록</button>
  </div>
  <div th:unless="${#strings.isEmpty(itemFormDto.id)}" style="text-align: center">
    <button th:formaction="@{'/admin/item/' + ${itemFormDto.id}}" type="submit" class="btn btn-primary">수 정</button>
  </div>
  
     ㄴ 상품 아이디가 없는 경우(상품을 처음 등록할 경우) 상품등록버튼을 보여주고
        상품의 아이디가 있는 경우 수 정버튼을 보여줌
 
properties 에 아래 내용 작성하기

# 파일 한 개 당 최대 크기
spring.servlet.multipart.maxFileSize=20MB

# 요청 당 최대 파일 크기
spring.servlet.multipart.maxRequestSize=100MB

# 상품 이미지 업로드 경로
itemImgLocation=C:/mall/itemImages

# resource upload path
uploadPath=file:///C:/mal/


업로드한 파일을 읽어올 경로 설정하기

WebMvcConfig 클래스 작성

      properties 파일에서 uploadPath의 값 가져와서
                              ㄴ file:///C:/mal/
      멤버변수 uploadPath 에 저장하기
	  @Value("${uploadPath}")
	  String uploadPath;
		  
		  
	registry.addResourceHandler("/images/**")  <-- 논리적 경로
	        .addResourceLocations(uploadPath); <-- 물리적 경로


FileService  <-- 파일 처리 담당하는 클래스
                 파일 업로드 메소드와 파일 삭제 메소드 작성

파일 업로드하기 : uploadFile()

UUID uuid = UUID.randomUUID();
  ㄴ UUID(Universally Unique Identifier)는 서로 다른 개체들을 구별하기 위해서 
     이름을 부여할 때 사용함. 실제 사용 시 중복될 가능성이 거의 없음. 
     (System.currentTimeMillis() 를 사용하는 것 보다 중복될 가능성이 적음)

String savedFileName = uuid.toString() + extension;
  ㄴ UUID로 받은 값과 원래 파일의 이름의 확장자를 조합해서 저장될 파일 이름을 만듬
      
FileOutputStream fos = new FileOutputStream(fileUploadFullUrl);
  ㄴ FileOutputStream 클래스는 바이트 단위로 data를 내보내는 클래스
     생성자로 파일이 저장될 위치와 파일의 이름을 넘겨 
     파일에 쓸 파일 출력 스트림(Stream : data 가 이동하는 경로(길))을 만듬	   
      
 byte[] fileData <- parameter 로 전달받은 byte 배열
fos.write(fileData); 
  ㄴ fileData(byte 배열)를 파일 출력 스트림으로 내보냄
  
return savedFileName;  <-- 업로드된 파일 이름을 반환함


파일 삭제하기 : deleteFile()

File deleteFile = new File(filePath)
 ㄴ 파일이 저장된 경로를 이용하여 파일 객체를 생성함


해당 파일이 존재하면 파일을 삭제합니다
if(deleteFile.exists()) {
  deleteFile.delete();
}
 
상품이미지정보를 저장하기 위해서 ItemImgRepository 작성하기
                                    ㄴ JpaRepository 를 상속받음
public interface ItemImgRepository extends JpaRepository<ItemImg, Long>{ }

ItemImgService 에서 ItemImgRepository 의 save() 호출하기
                                    

properties 에 설정한 itemImgLocation 값을
(C:/mall/itemImages)
가져와서 멤버변수 itemImgLocation 에 저장함                                    
@Value("${itemImgLocation}")
private String itemImgLocation;                             
                                    
imgName = fileService.uploadFile(itemImgLocation, oriImgName, itemImgFile.getBytes());
  ㄴ 사용자가 상품의 이미지를 등록했다면 저장할 경로와 파일의 이름, 
	  파일의 바이트 배열을 파일 업로드 파라미터로 해서 uploadFile 메소드를 호출합니다. 
	  호출 결과 로컬에 저장된 파일의 이름을 imgName 변수에 저장함. 
	  
imgUrl = "/images/itemImages/" + imgName;                                  
  ㄴ  저장한 상품 이미지를 불러올 경로를 설정함. 
	  외부 리소스를 불러오는 urlPattern으로 
	  WebMvcConfig 클래스에서 “/images/**”를 설정해 줌
	  application.properties에서 설정한 
	  uploadPath 프로퍼티 경로인 file:///C:/mal/ 아래 itemImages 폴더에
	  이미지를 저장하므로 상품 이미지롤 불러오는 경로로 “/images/itemImages/"를 붙여줌

 
ItemService 작성하기

ItemController 에
@PostMapping("/admin/item/new") 작성하기


 첫 번째 이미지는 반드시 등록해야 함
if(itemImgFileList.get(0).isEmpty() && itemFormDto.getId() == null) {
	model.addAttribute("errorMsg", "첫 번째 상품 이미지는 꼭 올려주세요");
	return "item/itemForm";
}

도메인주소/item_img 테이블의 img_url 컬럼의 값(이미지경로+이미지파일이름)
           ItemImgService 에서 설정한 imgUrl
           imgUrl = "/images/item/" + imgName;
                     이미지경로     + 이미지파일이름

images/item/66fa64d9-cbd5-490b-a122-70f71dac0089.jpg
  ㄴ 이미지 파일의 논리적 경로

브라우저 주소창에 아래 code 를 입력해서 이미지가 화면에 나오는지 확인하기
localhost/images/item/66fa64d9-cbd5-490b-a122-70f71dac0089.jpg


-- 상품 등록 관련 code 완료 --


-- 상품 정보 수정하기 --

ItemService 에

getItemDtl() 메소드 작성하기

실제 수정(변경)되는 내용이 없는 경우에는
 @Transactional(readOnly = true) 로 설정하는 것이 좋고
 
실제 수정(변경)되는 내용이 있는 경우에는
 @Transactional(readOnly = true) 을 설정하지 않아서
 Dirty Checking 이 되도록 해야 됨
 
상품 데이터를 읽어오는 트랜잭션을 읽기 전용으로 설정함 
JPA가 더티체킹(변경감지)을 수행하지 않아서 성능이 향상됨
@Transactional(readOnly = true)
public ItemFormDto getItemDtl(Long itemId) { }

List<ItemImg> itemImgList = 
  itemImgRepository.findByItemIdOrderByIdAsc(itemId);
ㄴ 해당 상품의 이미지 조회하기 등록 오름차순으로 조회함

for(ItemImg itemImg : itemImgList) { }
ㄴ 조회한 ItemImg 엔티티를 ItemImgDto 로 만들고
   itemImgDto 을 itemImgDtoList 에 저장함

Item item = 
	itemRepository.findById(itemId).orElseThrow(
			() -> new EntityNotFoundException("해당 상품이 없습니다 (id : " + itemId + ")"));
ㄴ 상품의 아이디를 가지고 상품 엔티티를 가져옴(select)

주소표시줄에 
localhost/admin/item/3 
입력해서
상품아이디가 3인 
상품 정보가 화면에 나오는지 확인하기

*************************************************************

실제 수정(변경)되는 내용이 없는 경우에는
 @Transactional(readOnly = true) 로 설정하는 것이 좋고
 
실제 수정(변경)되는 내용이 있는 경우에는
 @Transactional(readOnly = true) 을 설정하지 않아서
 Dirty Checking 이 되도록 해야 됨
 
ㄴ ItemImgService 의 updateItemImg () 메소드는
   실제 수정(변경) 작업을 하기 때문에
   @Transactional(readOnly = true) 을 설정하지 않아서
   Dirty Checking 이 되도록 해야 됨	

*************************************************************


ItemImgService 의 updateItemImg () 메소드
 
if(!itemImgFile.isEmpty()) 
  ㄴ 상품 이미지를 수정한 경우

ItemImg savedItemImg = 
  itemImgRepository.findById(itemImgId).orElseThrow(EntityNotFoundException::new);
    ㄴ 상품 이미지 아이디를 이용하여 기존에 저장했던 상품 이미지 엔티티를 가져옴 
    
if(!StringUtils.isEmpty(savedItemImg.getImgName()))
   ㄴ 기존에 등록된 상품 이미지 파일이 있을 경우 해당 파일을 삭제함   
			
String imgName = fileService.uploadFile(itemImgLocation, oriImgName, itemImgFile.getBytes());
   ㄴ 업데이트한 상품 이미지 파일을 업로드함

savedItemImg.updateItemImg(imgName, oriImgName, imgUrl);
   ㄴ 변경된 상품 이미지 정보를 세팅함
		상품 등록 때처럼 itemlmgRepository.saveO 메소드를 호출하지는 않음 
		savedItemImg 엔티티는 현재 영속 상태이므로 데이터를 변경하는 것만으로도
		(Dirty Checking 에 의해서)
		변경 감지 기능이 동작하여 트랜잭션이 끝날 때 update 쿼리가 실행됨
		ㄴ 엔티티가 영속 상태여야 함

Item Entity 의 updateItem() 메소드 
    상품 수정하기 : 상품 정보 수정시 호출됨
    Item Entity 의 상태가 변경되면
    ItemRepository 의 save() 를 호출하지 않아도
	Dirty Checking(변경감지기능)에 의해서 DB 도 자동으로 갱신됨
	ItemFormDto : 화면에 입력한 수정 정보를 저장하고 있는 DTO
	
ItemService 의 updateItem() 메소드
   실제 수정(변경) 작업을 하기 때문에
   @Transactional(readOnly = true) 을 설정하지 않아서
   Dirty Checking 이 되도록 해야 됨	

Item item = itemRepository.findById(itemFormDto.getId())
				          .orElseThrow(EntityNotFoundException::new);
	 ㄴ 상품 등록 화면으로부터 전달 받은 상품 아이디를 이용하여 
	     상품 엔티티를 가져옴(조회함)	
 
item.updateItem(itemFormDto);
  ㄴ Item Entity 의 updateItem() 메소드 호출하기
     Dirty Checking 기능 수행
     (Persistence 영역에 있는 Entity 클래스와 DB 의 table 을 동기화함)
     
List<Long> getItemImgIds = itemFormDto.getItemImgIds();
    ㄴ 상품 이미지 아이디 리스트를 조회함(가져옴) 
  
itemImgService.updateItemImg(getItemImgIds.get(i), itemImgFileList.get(i));
    ㄴ 상품 이미지를 업데이트하기 위해서 updateItemImg() 메소드를 호출하면서 
       상품 이미지 아이디와 상품 이미지 파일 정보를 파라미터로 전달함
       
       
ItemController

    실제로 상품 수정 하기
	@PostMapping("/admin/item/{itemId}")
	public String updateItem(....) 메소드
	   itemService.updateItem(itemFormDto, itemImgFileList);
	     ㄴ 실제로 상품 정보를 수정하는 메소드를 호출함
	
	
	
	
-- 상품 관리하기 : 상품 관리 페이지로 이동하기 --

   등록한 상품 목록 화면에 나타내기
   페이징 기능 구현
   상품을 선택하면 해당 상품 상세 페이지로 이동하기


조회 조건
  상품등록일
  상품판매상태
  상품이름 / 상품등록자 아이디
       
조회 조건이 좀 복합한 경우
Querydsl 을 사용해서 조건에 맞는 query 를 
Q클래스의 메소드를 사용해서 실행할 수 있음



20240426


ItemSearchDto


private String searchDateType

현재 시간과 상품 등록일을 비교해서 상품 데이터를 조회

 조회 시간 기준

• all： 상품 등록일 전체
• 1d： 최근 하루 동안 등록된 상품
• 1w： 최근 일주일 동안 등록된 상품
• 1m： 최근 한달 동안 등록된 상품
• 6m： 최근 6개월 동안 등록된 상품
  
  
  
private ItemSellStatus searchSellStatus
 
 상품의 판매상태를 기준으로 상품 데이터를 조회
 
 
private String searchBy;
	
 상품을 조회할 때 어떤 유형으로 조회할지 선택
• itemNm： 상품명
• createdBy： 상품 등록자 아이디
 
 
private String searchQuery="";
조회할 검색어 저장할 변수

searchBy가 itemNm일 경우 상품명을 기준으로 검색
createdBy일 경우 상품 등록자 아이디 기준으로 검색
 
 
Querydsl을 Spring Data Jpa과 함께 사용하기 위해서는 
사용자 정의 리포지토리를 정의해야 함

총 3단계의 과정으로 구현
1. 사용자정의 인터페이스 작성
2. 사용자 정의 인터페이스 구현
3. Spring Data Jpa 리포지토리에서 사용자 정의 인터페이스 상속
 
 
 
 
1. 사용자정의 인터페이스 작성

ItemRepositoryCustom 인터페이스

 Page<Item> getAdminItemPage(ItemSearchDto itemSearchDto, Pageable pageable);
 상품 조회 조건을 담고 있는 itemSearch Dto 객체와 
 페이징 정보를 담고 있는 pageable 객체를 파라미터로 받는
 getAdminltemPage 메소드를 정의
 Page<Item> 객체를 반환
 
 
ItemRepositoryCustom 인터페이스를 구현한 클래스 
ItemRepositoryCustomImpl


Querydsl의 장점

Querydsl에서는 BooleanExpression이라는 
where절에서 사용할 수 있는 값을 지원함
BooleanExpression을 반환하는 메소드를 만들고 
해당 조건들을 다른 쿼리를 생성할 때 사용할 수 있기 때문에 
중복 코드를 줄일 수 있다는 장점이 있음


	// query 를 동적으로 생성함
	private JPAQueryFactory jpaQueryFactory



    // 생성자에서 entityManager를 argument 로 하는 JPAQueryFactory 객체 생성함
	public ItemRepositoryCustomImpl(EntityManager entityManager) {
		this.jpaQueryFactory = new JPAQueryFactory(entityManager);
	}
 
 
 
    private BooleanExpression searchSellStatusEq(ItemSellStatus searchSellStatus) {
	
	 return searchSellStatus == null ? null : item.itemSellStatus.eq(searchSellStatus);
	
     상품 판매 상태 조건이 전체(null)일 경우는 null을 리턴함. 
     결과값이 null이면 where절에서 해당 조건은 무시됨 
     상품 판매 상태 조건이 null이 아니라 
     판매중 또는 품절 상태라면 해당 조건의 상품만 조회함


  private BooleanExpression regDtsAfter(String searchDateType) 
  
    searchDateType의 값에 따라서 dateTime의 값을 이전 시간의 값으로 세팅 후 
    해당 시간 이후로 등록된 상품만 조회함. 
    예를 돌어 searchDateType 값이 “1m”인 경우 dateTime의 시간을 
    한 달 전으로 세팅 후 최근 한 달 동안 등록된 상품만 조회하도록 조건값을 반환함
    
    
  private BooleanExpression searchByLike(String searchBy, String searchQuery) {
	
    searchBy의 값에 따라서 상품명에 검색어를 포함하고 있는 
    상품 또는 상품 생성자의 아이디에 검색어를 포함하고있는 상품을 
    조회하도록 조건값을 반환함
    
    
    @Override
	@Transactional(readOnly=true) <-- Dirty Checking 이 일어나지 않아서 성능이 향상됨
	public Page<Item> getAdminItemPage(ItemSearchDto itemSearchDto, Pageable pageable) {
	  
   List<Item> content = queryFactory.selectFrom(item)
            		                .where(regDtsAfter(itemSearchDto.getSearchDateType()),
            		                		    searchSellStatusEq(itemSearchDto.getSearchSellStatus()),
            		                		    searchByLike(itemSearchDto.getSearchBy(), itemSearchDto.getSearchQuery()))
            		                .orderBy(item.id.desc())
            		                .offset(pageable.getOffset())
            		                .limit(pageable.getPageSize())
            		                .fetch();
    
     queryFactory를 이용해서 쿼리를 생성함
	쿼리문을 직접 작성할 때의 형태와 문법이 비슷한 것을 볼 수 있음
	• selectFrom(item): 상품 데이터롤 조회하기 위해서 QItem의 item을 지정함
	• where 조건절: BooleanExpression 반환하는 조건문들을 넣어줌.
	  ‘,’ 단위로 넣어줄 경우 and 조건으로 인식함
	• offset: 데이터를 가지고 올 시작 인덱스를 지정함
	• limit: 한 번에 가지고 올 최대 개수를 지정함
	• fetch()： 쿼리 실행 <-- List<Item>  를 반환함
	
	
	return new PageImpl<>(content, pageable, total)
	   조회한 데이터를 Page 클래스의 구현체인 Pagelmpl 객체로 반환
	
	
	
	Querydsl 조회 결과를 반환하는 메소드

	QueryResults<T> fetchResults() 
	조회 대상 리스트 및 전체 개수를 포함하는 QueryResults 반환
	
	List<T> fetch() 
	조회 대상 리스트 반환
	
	T fetch0ne() 
	조회 대상이 1건이면 해당 타입 반환.
	조회 대상이 1건 이상이면 에러 발생
	
	T fetchFirst() 
	조회 대상이 1건 또는 1건 이상이면 1건만 반환
	
	long fetchCount() 
	해당 데이터 전체 개수 반환. count 쿼리 실행
		
		
		
	ItemRepositoryCustom 인터페이스
		
    main 화면에 보여줄 상품 목록 조회하기
	Page<MainItemDto> getMainItemPage(ItemSearchDto itemSearchDto, Pageable pageable);
	
	ㄴ ItemRepositoryImpl 클래스에서 overriding 함
	
	@Override
	@Transactional(readOnly=true) <-- Dirty Checking 이 일어나지 않아서 성능이 향상됨
	public Page<Item> getAdminItemPage(ItemSearchDto itemSearchDto, Pageable pageable) {
		
	
	
	
	ItemController
	value= <-- 생략 가능
	@GetMapping(value={"/admin/items", "/admin/items/{page}"})
	value에 상품 관리 화면 진입 시 URL에 페이지 번호가 없는 경우와 
	페이지 번호가 있는 경우 2가지를 매핑함
	
	Pageable pageable = PageRequest.of(page.isPresent() ? page.get() : 0, 3);
	페이징을 위해서 PageReques.of() 메소드를 통해 Pageable 객체를 생성함
	첫 번째 파라미터로는 조회할 페이지 번호
	두 번째 파라미터로는 한 번에 가지고 올 데이터 수
	URL 경로에 페이지 번호가 있으면 해당 페이지를 조회하도록 세팅하고, 
	페이지 번호가 없으면 0페이지를 조회하도록 함
	
	Page<Item> items = itemService.getAdminItemPage(itemSearchDto, pageable);
	조회 조건과 페이징 정보를 파라미터로 넘겨서 Page<Item> 객체를 반환 받음
	
	model.addAttribute("items", items);
	조회한 상품 데이터 및 페이징 정보를 뷰에 전달함
	
	model.addAttribute("itemSearchDto", itemSearchDto);
	페이지 전환 시 기존 검색 조건을 유지한 채 이동할 수 있도록 뷰에 다시 전달함
	
	model.addAttribute("maxPage", 5);
    상품 관리 메뉴 하단에 보여줄 페이지 번호의 최대 개수 설정
    최대 5개의 이동할 페이지 번호만 보여줌
 
 
    
    item 폴더에 itemMng.html 작성함
    
    
     $(document).ready(function(){
    	$("#searchBtn").on("click", function(e){
    		e.preventDefault();  〈검색〉버튼 클릭 시 form 태그가 전송되지 않도록 함
    		page(0); 〈검색〉버튼을 클릭할 페이지 번호로 0번 째 페이지를 조회하는 page 함수를 호출함
    	});
      });
    
    function page(page)
    이동할 페이지 값을 받아서 현재 조회조건으로 설정된 
    상품 등록 기간. 판매 상태. 조회 유형. 검색어를 파라미터로 설정 후 
    상품 데이터를 조회함
    
    
    <tr th:each="item, status: ${items.getContent()}">
    items.getContent() 메소드를 호출하면 조회한 상품 데이터를 리스트를 얻음. 
    해당 리스트를 th：each를 통해서 반복적으로 테이블의 row 를 화면에 표시함
    
    <td th:text="${item.itemSellStatus.name.equals('SELL')} ? '판매중' : '품절'"></td>
    현재 상품의 판매 상태가 “SELL”이면 ‘판매중’으로. 같지 않으면 ‘품절’로 표시함
   
    <div th:with="start=${(items.number/maxPage)*maxPage + 1}, end=(${(items.totalPages == 0) ? 1 : (start + (maxPage - 1) < items.totalPages ? start + (maxPage - 1) : items.totalPages)})" >
    th：with는 변수값을 정의할 때 사용함
	페이지 시작 번호(start)와 페이지 끝 페이지 번호(end)를 구해서 저장함
	• start = (현재 페이지 번호/보여줄 페이지수) + 1
	• end = start + (보여줄 페이지 수 - 1)
    
    <li class="page-item" th:classappend="${items.first}?'disabled'">
    첫 번째 페이지면 이전 페이지로 이동하는〈이전〉버튼을 선택 불가능하도록 disabled 클래스를 추가함
    
    <li class="page-item" th:classappend="${items.last}?'disabled'">
    마지막 페이지일 경우 다음 페이지로 이동하는〈다음〉버튼을 선택 불가능하도록 disabled 클래스를 추가함
    
    <a th:onclick="'javascript:page(' + ${items.number - 1} + ')'" aria-label="Previous" class="page-link">
    이전버튼 클릭 시 현재 페이지에서 이전 페이지로 이동하도록 page 함수를 호출            
    
    <a th:onclick="'javascript:page(' + ${items.number + 1} + ')'" aria-label="Next" class="page-link">
    다음버튼 클릭 시 현재 페이지에서 다음 페이지로 이동하도록 page 함수를 호출            
                    
    <li class="page-item" th:each="page: ${#numbers.sequence(start, end)}" th:classappend="${items.number eq page-1}?'active':''">
          현재 페이지이면 active 클래스값을 추가
          
    <a th:onclick="'javascript:page(' + ${page - 1} + ')'" th:inline="text" class="page-link">[[${page}]]</a>
    페이지 번호 클릭 시 해당 페이지로 이동하도록 page 함수를 호출             
          
          
--------------------------------------------------------------------------------------------------------------------------------------------------------



  메인 화면 구성하기
  
  
  Querydsl 을 사용해서 paging 처리함
  화면 오른쪽 위에 있는 검색버튼을 사용해서 검색 기능을 구현함
  
  MainItemDto 에서
  생성자에 @QueryProjection 설정함
                  ㄴ 상품 검색시 DTO 객체로 결괏값을 받음
                  ㄴ @QueryProjection 을 사용하면
                     DB로 부터 Item Entity 객체로 값을 받은 후
                     DTO 클래스로 변환하는 과정 없이 
                     바로 DTO 객체를 추출해서 사용할 수 있음
  
  @QueryProjection 어노테이션을 생성자에 설정하면
  해당 클래스(MainItemDto) 의 Q클래스가 생성됨
  
  
  ItemRepositoryCustom 에
  // main 화면에 보여줄 상품 목록 조회(select)하기
  Page<MainItemDto> getMainItemPage(ItemSearchDto itemSearchDto, Pageable pageable);
	ㄴ 추상 메소드 작성
	
  private BooleanExpression itemNmLike(String searchQuery) 
    return StringUtils.isEmpty(searchQuery) ? null : item.itemNm.like("%" + searchQuery + "%");
    ㄴ 검색어가 null이 아니면 상품명에 해당 검색어가 포함되는 상품을 조회하는 조건을 반환함
  
  
  ItemRepositoryCustomImpl 에	  
	추상메소드 getMainItemPage() 를 overriding 함
  
  queryResults = 
    queryFactory.select(new QMainItemDto(item.id, item.itemNm, item.itemDetail, itemImg.imgUrl, item.price)
                             ㄴ  QMainItemDto의 생성자에 parameter 에 전달할 값들을 넣어줍니다. 
                                 @QueryProjection을 사용하면 DTO로 바로 조회가 가능함 
                                 엔티티 조회 후 DTO로 변환하는 과정을 줄일 수 있음                        
                .join(itemImg.item, item)
                             ㄴ itemlmg와 item을 내부 조인(inner join)함
                             
                .where(itemImg.repimgYn.eq("Y"))               
                             ㄴ 상품 이미지의 경우 대표 상품 이미지만 보여줌



   ItemService 에 main page 에 보여줄 
   상품 데이터를 조회하는 메소드 작성
     ㄴ public Page<MainItemDto> getMainItemPage(ItemSearchDto itemSearchDto, Pageable pageable){
		  return itemRepository.getMainItemPage(itemSearchDto, pageable);
	    }
   
   
   HomeController 작성
   
   @GetMapping("/")
	public String home(
	ItemSearchDto itemSearchDto, Optional<Integer> page, Model model) 메소드 작성
	
	
	
    main.html 작성하기
    
    <div id="carouselControls" class="carousel slide margin" data-ride="carousel">
    부트스트랩의 슬라이드를 보여주는 Carousel 컴포넌트를 이용하여 배너를 만듬
    쇼핑몰의 경우 일반적으로 현재 행사 중인 상품을 광고하는 데 사용함
    
    
    <input type="hidden" name="searchQuery" th:value="${itemSearchDto.searchQuery}" />
    쇼핑몰 오른쪽 상단의 Search 기능을 이용해서 상품을 검색할 때 
    페이징 처리 시 해당 검색어를 유지하기 위해서    
    hidden 값으로 설정해서(type="hidden) 검색어가 사라지지 않도록 함
    
    	
	<p class="h3 font-weight-bold" th:text="${itemSearchDto.searchQuery} + '검색 결과'">	
    상품을 검색했을 때 어떤 검색어로 조회된 결과인지 보여줌
   
    <th:block th:each="item, status: ${items.getContent()}">
    조회한 메인 상품 데이터를 보여줌. 부트스트랩의 Card 컴포넌트롤 이용함. 
    사용자가 카드 형태(<div class="card">)로 상품의 이름. 내용. 가격을 볼 수 있음
   
   
------------------------------------------------------------------------------------------------------------



상품 상세 페이지

ItemController 에
@GetMapping("/item/{itemId}")
  public String itemDetail(@PathVariable("itemId") Long itemId, Model model) 
메소드 작성

return "item/itemDtl";
item 폴더에 itemDtl.html 작성


function calculateTotalPrice()
현재 주문할 수량과 상품 한 개당 가격을 곱해서
결제 금액을 구해주는 함수


<div th:each="itemImgDto : ${item.itemImgDtoList}" class="text-center">
등록된 상품 이미지를 반복 구문을 통해 보여줌



------------------------------------------------------------------------------------------------------------


상품 주문하기

상품을 주문하면 현재 상품 재고가 주문한 수량만큼 감소함
주문 수량이 현재 재고량 보다 작거나 같아야 함 
주문 수량이 현재 재고량 보다 크면 주문이 되지 않도록 함

주문 수량이 현재 재고량 보다 크면 OutOfStockException 을 발생시킴
RuntimeException 클래스를 상속 받는 OutOfStockException 클래스 작성함
exception 패키지에 작성함

Item Entity 에
removeStock() 메소드를 작성한
 ㄴ 남은 재고량   =    현재 재고량   -    주문수량
    int restStock = this.stockNumber - orderedAmount;
 		
주문 수량이 현재 재고량 보다 크면 		
if(restStock < 0)
OutOfStockException 을 발생시킴
throw new OutOfStockException("재고가 부족합니다 (현재 재고수량 :  " + this.stockNumber + ")");
			
재고가 부족하지 않아서 정상적으로 주문이 되는 경우
주문 후 남은 재고 수량을 상품의 현재 재고 값으로 할당
this.stockNumber = restStock;


주문할 상품과 주문 수량을 가지고
OrderItem 객체 생성하기
 ㄴ OrderItem Entity 클래스 작성하기
 
createOrderItem() 메소드 작성하기 
주문할 상품과 수량(count)을 전달 받아서 OrderItem 객체를 생성해서 반환하기
public static OrderItem createOrderItem(Item item, int count) { }

OrderItem orderItem = new OrderItem();
orderItem.setItem(item);  <-- 주문할 상품 세팅
orderItem.setCount(count);  <-- 주문할  주문 수량 세팅
orderItem.setOrderPrice(item.getPrice());  <-- 주문 가격 세팅

주문 가격 : 할인 적용, 쿠폰 사용에 따라서 달라질 수 있음

주문하는 상품의 개수만큼 해당 상품의 재고량 감소시키기
item.removeStock(count);

// 현재 상품 하나의 총가격(단가 X 수량)
//              orderPrice X count
public int getTotalPrice() {
	return orderPrice * count;
}


Order Entity 클래스에서...

    //주문할 때, 주문 상품(orderItem) 증가하기
	// 주문하는 상품들을 모아두는 List 에 주문 상품(orderItem) 저장하기
	// 마켓에 올려놓은 상품 중에서 장바구니에 담는 상품만
	// orderItemList 에 추가하기	
	public void addOrderItem(OrderItem orderItem) {
		this.orderItems.add(orderItem);
		// order_item 테이블의 외래키인 order_id 컬럼에
		// 현재 주문하는 주문테이블의 아이디(item_id) 값을 추가함
	    // Order 클래스의 멤버변수 Order order 의 setter 를 호출함
		orderItem.setOrder(this);
		
	}

	// Oder 객체를 생성해서 반환하기
	// 주문할 때는 주문하는회원정보, 주문상품목록이 필요함
	// 주문하는회원정보(Member member), 주문상품목록(List<OrderItem> orderItemList)
	public static Order createOrder(Member member, List<OrderItem> orderItemList) {
		Order order = new Order();
		order.setMember(member);
		
		// 마켓에 올려놓은 상품 중에서 장바구니에 담는 상품만
		// orderItemList 에 추가하기
		for(OrderItem orderItem : orderItemList) {
			order.addOrderItem(orderItem);
		}
		
		order.setOrderStatus(OrderStatus.ORDER);
		order.setOrderDate(LocalDateTime.now());
		
		return order;
	}

	// 총 주문 가격
	// 주문한 모든 상품의 총가격
	public int getTotalPrice() {
		int totalPrice = 0;
		
		for(OrderItem orderItem : orderItems) {
			totalPrice += orderItem.getTotalPrice();
		}
		return totalPrice;
	}


  OrderDto
     ㄴ 상품 상세 페이지(itemDtl.html - front)에서
        주문할 상품 아이디와 주문 수량을 전달 받을
        OrderDto 클래스 작성하기
        

  OrderService 
     ㄴ 상품 주문 logic 작성
        OrderService 에서 사용할
        ItemRepository
        MemberRepository
        OrderRepository
        ItemImageRepository
        객체들을 
        @RequiredArgsConstructor 로
        주입받기 <-- private final 
        
        OrderRepository 작성하기
        
        
 	/*
	  주문번호(order_id: Order 의 id)를 반환하는 메소드
	  parameter : orderDto / email /   
	*/
	public Long order(OrderDto orderDto, String email) 메소드 작성하기
     : 소스에 작성한 설명 참고
     
     
  OrderController 작성
  @PostMapping("/order")
  @ResponseBody
  public ResponseEntity order(@RequestBody @Valid OrderDto orderDto, BindingResult result,
			                        Principal principal) {} 메소드
	
  Spring Framework 에서 비동기(Ajax) 처리할 때			  
  @ResponseBody	： HTTP 요청의 본문 body에 담긴 내용을 자바 객체로 전달		                        
  @RequestBody  ： 자바 객체를 HTTP 요청의 body로 전달
  
  return new ResponseEntity<String>(sb.toString(), HttpStatus.BAD_REQUEST);               
                 ㄴ 에러 정보를 ResponseEntity 객체에 담아서 반환함
                 
                   
  String email = principal.getName();
   ㄴ 현재 로그인 유저의 정보를 얻기 위해서 
      ©Controller 어노테이션이 선언된 클래스에서 
      메소드 parameter 로 principal 객체를 넘겨 줄 경우 
      해당 객체에 직접 접근할 수 있음 
      principal 객체에서 현재 로그인한 회원의 이메일 정보를 조회함


  orderid = orderService.order(orderDto, email);
    ㄴ 화면으로부터 넘어오는 주문 정보와 회원의 이메일 정보를 이용하여 
       주문 로직을 호출함
	

  return new ResponseEntity<Long>(orderid, HttpStatus.OK);
    ㄴ 결과값으로 생성된 주문 번호와 요청이 성공했다는 HTTP 응답 상태 코드를 반환함


  
  itemDtl.html
   function order()
        var token = $("meta[name='_csrf']").attr("content");
        var header = $("meta[name='_csrf_header']").attr("content");
          ㄴ 스프링 시큐리티를 사용할 경우 기본적으로 POST 방식의 데이터 전송에는 
              CSRF 토큰 값이 필요하므로 해당 값들을 조회함
  
  paramData 객체(리터럴 객체) 생성하기
  주문할 상품의 아이디와 주문 수량 데이터를 전달할 객체를 생성함
  let paramData = {
	    itemId : $("#itemId").val(),
	    count : $("#count").val()
	};
  
  let param = JSON.stringify(paramData) 
    ㄴ 서버에 보낼 주문 데이터를 json으로 변경함
  
  contentType : "application/json",   
    ㄴ 서버에 데이터를 보낼 형식을 json으로 지정함
    
  dataType : "json",
    ㄴ 서버에서 결과값으로 받을 데이터의 타입을 json으로 설정함


  success  : function(result, status){
                alert("주문이 완료 되었습니다.");
                location.href='/';
  },
    ㄴ 주문 로직 호출이 성공하면 “주문이 완료되었습니다.”라는 메시지를 보여주고 
       메인 페이지로 이동함

  error : function(jqXHR, status, error){

                if(jqXHR.status == '401'){
                    alert('로그인 후 이용해주세요');
                    location.href='/members/login';
                } 
    ㄴ 현재 로그인 상태가 아니라면 “로그인 후 이용해주세요”라는 
       메시지를 보여주고 로그인 페이지로 이동함

  else{
                    alert(jqXHR.responseText);
                }
  }
    ㄴ 주문 시 에러가 발생하면 해당 메시지를 보여줌
    
    
------------------------------------------------------------------------------------------------------------
   
   
  주문 이력 조회하기
  
  
  조회한 주문 데이터를 화면에 보여줄 때 사용할
  OrderItemDto 클래스 작성하기
  public OrderItemDto(OrderItem orderItem, String imgUrl) 
  
  생성자를 사용해서 멤버 변수 값을 세팅함
  OrderItemDto 클래스의 생성자로 
  orderItem 객체와 이미지 경로를 파라미터로 받아서 
  멤버 변수 값을 세팅함
  
  
  주문 내역 정보를 저장하는 OrderHistDto 클래스 작성
  생성자
  public OrderHistDto(Order order)
    ㄴ OrderHistDto 클래스의 생성자로 order 객체를 파라미터로 받아서 멤버 변수 값을 세팅함
       주문 날짜의 경우 화면에 “yyyy-MM-dd HH：mm' 형태로 전달하기 위해서 포맷을 수정함
  
  
  OrderRepository 인터페이스에 @Query Annotation 을 설정해서
  주문이력을 조회하는 query 문 작성하기  <-- JPQL 문법으로 작성함
    ㄴ 조회 조건이 복잡한 경우에는 JPQL 문법으로 작성하고
       복잡하지 않는 경우에는 Querydsl 로 작성함
       
  @Query("select o from Order o " +
	     "where o.member.email = :email " +
		 "order by o.orderDate desc")
  List<Order> findOrders(String email, Pageable pageable);
	ㄴ 현재 로그인한 사용자의 주문 데이터를 페이징 조건에 맞춰서 조회함
	
		
	@Query("select count(o) from Order o " + 
	       "where o.member.email = :email") 
	Long countOrder(@Param("email") String email);	
	  ㄴ 현재 로그인한 회원의 주문 개수가 몇 개인지 조회함
       
       
       
  ItemImgRepository 인터페이스에
  상품의 대표 이미지를 찾는 메소드를 추가함
    ㄴ 주문 이력 페이지에서 주문 상품 목록에 대포 이미지를 출력하기 위함     
    // 상품 대표 이미지 가져오기
	// Long itemId : 주문서에 올라간 item 의 id 가 아니고
	// 							 상품 등록할 때 정해진 id
	ItemImg findByItemIdAndRepImgYn(Long itemId, String repImgYn);
  
  OrderService 에
  주문 목록을 조회하는 메소드 추가함
    public Page<OrderHistDto> getOrderList(String email, Pageable pageable)
  
                      OrderRepository 에 findOrders() 메소드 추가하기
                                           ↓↓↓↓↓
    List<Order> orders = orderRepository.findOrders(email, pageable)
      ㄴ 유저의 아이디와 페이징 조건을 이용하여 주문 목록을 조회함
    
    Long totalCount = orderRepository.countOrder(email)
      ㄴ 유저의 주문 총 개수를 구함
      
    for(Order order: orders)  
      ㄴ 주문 리스트(orders)를 순회하면서 구매 이력 페이지에 전달할 DTO(OrderHistDto) 생성    
      
    ItemImg itemImg = 
		  			itemImgRepository.findByItemIdAndRepImgYn(orderItem.getItem().getId(), "Y");
      ㄴ 주문한 상품의 대표 이미지를 조회함
  
  
    return new PageImpl<OrderHistDto>(orderHistDtos, pageable, totalCount)
      ㄴ 페이지 구현 객체를 생성하여 반환함
    
  
  
    OrderController 에서
    @GetMapping({"/orders", "/orders/{page}"}) 메소드 작성하기
  
    Pageable pageable = PageRequest.of(page.isPresent() ? page.get() : 0, 4);
      ㄴ 한 번에 가지고 올 주문의 개수는 4개로 설정함
  
  
    Page<OrderHistDto> orderHistDtoList = orderService.getOrderList(principal.getName(), pageable)
										      ㄴ  현재 로그인한 회원의 이메일과 페이징 객체를 파라미터로 전달하여 
										          화면에 전달한 주문 목록 데이터를 리턴 값으로 받음
										          
										          
    order 폴더에 orderHist.html 작성하기
    
    
    										          
  
------------------------------------------------------------------------------------------------------------
   
  
  주문 취소하기
    ㄴ OrderStatus 를 CANCEL 로 변경하고
       주문시 감소된 재고량 만큼 다시 증가시켜줌 (원래대로...)
       
  상품의 재고를 증가시키는 메소드 -  Item 클래스에 addStock 메소드를 생성함
         주문을 취소할 경우 주문 수량만큼 상품의 재고를 증가시키는 메소드
         
  Orderitem 클래스에 public void cancel()  작성
     주문 취소 시 주문 수량만큼 상품의 재고를 더함
     
     
  Order 클래스에 public void cancelOrder() 작성
  
  OrderService 클래스에
  Transactional( readonly = true )
  public boolean validateOrder( ) 작성
  
  public boolean validateOrder(Long orderId, String email)
     현재 로그인한 사용자와 주문 데이터를 생성한 사용자가 같은지 검사함 
     같을 때는 true를 반환하고 같지 않을 경우는 false를 반환
     
  public void cancelOrder(Long orderId){
        Order order = orderRepository.findById(orderId)
                                     .orElseThrow(EntityNotFoundException::new);
                                     
                                     Dirty Checking
        // 주문 취소 상태로 변경하면 변경 감지 기능에 의해서 트랜잭션이 끝날 때 update 쿼리가 실행됨                                     
        order.cancelOrder();
  }    
     
     
  OrderController 클래스에 주문번호(orderId)를 받아서 
  주문 취소 메소드 호출하기
  
  
     
  order 폴더에 있는 orderHist.html 에 javascript 추가하기
  
  function cancelOrder(orderId) {
            let token = $("meta[name='_csrf']").attr("content");
            let header = $("meta[name='_csrf_header']").attr("content");

            let url = "/order/" + orderId + "/cancel";
            let paramData = {
                orderId : orderId,  <-- 취소할 주문 번호를 파라미터로 넘겨줌
            };

            let param = JSON.stringify(paramData);

            $.ajax({
                url      : url,
                type     : "POST",
                contentType : "application/json",
                data     : param,
                beforeSend : function(xhr){
                    /* 데이터를 전송하기 전에 헤더에 csrf값을 설정 */
                    xhr.setRequestHeader(header, token);
                },
                dataType : "json",
                cache   : false,
                success  : function(result, status){
                    // 주문이 정상적으로 취소됐으면 현재 페이지로 다시 redirect 함
                    alert("주문이 취소 되었습니다.");
                    location.href='/orders/' + [[${page}]];
                },
                error : function(jqXHR, status, error){
                	alert('로그인 후 이용해주세요');
                    location.href='/members/login';
                }
            });
        }
     
     
     
------------------------------------------------------------------------------------------------------------
   
  장바구니 기능 구현
  
  
  CartltemDto 작성
  
  회원 한 명당 1 개의 장바구니를 갖으므로 
  처음 장바구니에 상품을 담을 때는 해당 회원의 장바구니를 생성함 
  
  
  Cart 클래스에 회원 엔티티를 파라미터로 받아서 장바구니 엔티티를 생성하는 메소드 추가함
  
      public static Cart createCart(Member member){
        Cart cart = new Cart();
        cart.setMember(member);
        return cart;
      }
    
 
  CartItem 클래스에 아래 메소드 추가하기  
  createCartItem()
  addCount(int count)
  updateCount(int count) 
    ㄴ  장바구니에 기존에 담겨 있는 상품을 추가로 장바구니에 또 담을 때 
        기존 수량에 현재 담을 수량을 더함


  현재 로그인한 회원의 Cart 엔티티를 찾기 위해서 CartRepository에 쿼리 메소드 추가
    ㄴ  Cart findByMemberId(Long memberId);
  
  
  장바구니에 들어갈 상품올 저장하거나 조회하기 위해서
  CartltemRepository 인터페이스를 생성
  
  CartItem findByCartIdAndItemId(Long cartId, Long itemId);
    ㄴ  카트 아이디와 상품 아이디를 이용해서 상품이 장바구니에 들어있는지 조회
  
  
  CartService 클래스 생성
  
  
      public Long addCart(CartItemDto cartItemDto, String email){
        // 장바구니에 담을 상품 엔티티 조회
        Item item = itemRepository.findById(cartItemDto.getItemId())
                .orElseThrow(EntityNotFoundException::new);
                
        // 현재 로그인한 회원 엔티티 조회        
        Member member = memberRepository.findByEmail(email);

        // 현재 로그인한 회원의 장바구니 엔티티 조회
        Cart cart = cartRepository.findByMemberId(member.getId());
        
        // 상품을 처음으로 장바구니에 담을 경우 해당 회원의 장바구니 엔티티 생성  
        if(cart == null){
            cart = Cart.createCart(member);
            cartRepository.save(cart);
        }

        // 현재 상품이 장바구니에 이미 들어가 있는지 조회
        CartItem savedCartItem = cartItemRepository.findByCartIdAndItemId(cart.getId(), item.getId());

        if(savedCartItem != null){
        
            // 장바구니에 이미 있던 상품일 경우 기존 수량에 현재 장바구니에 담을 수량 만큼 더함
            savedCartItem.addCount(cartItemDto.getCount());
            return savedCartItem.getId();
        } else {
            // 장바구니 엔티티, 상품 엔티티, 장바구니에 담을 수량으로 CartItem 엔티티 생성
            CartItem cartItem = CartItem.createCartItem(cart, item, cartItemDto.getCount());
            // 장바구니에 들어갈 상품 저장
            cartItemRepository.save(cartItem);
            return cartItem.getId();
        }
      }
  
  
  
  CartController 클래스 작성
  
  @PostMapping("/cart")
    @ResponseBody
    public ResponseEntity order(@RequestBody @Valid CartItemDto cartItemDto, BindingResult bindingResult, Principal principal){

        // DTO 에 작성한 유효성 검사 annotation 에 의한 Error 발생하는 경우
        if(bindingResult.hasErrors()){
            StringBuilder sb = new StringBuilder();
            List<FieldError> fieldErrors = bindingResult.getFieldErrors();

            for (FieldError fieldError : fieldErrors) {
                sb.append(fieldError.getDefaultMessage());
            }

            return new ResponseEntity<String>(sb.toString(), HttpStatus.BAD_REQUEST);
        }

        // 현재 로그인한 회원의 이메일 정보를 변수에 저장
        String email = principal.getName();
        Long cartItemId;

        try {
            // 화면으로부터 넘어온 장바구니에 담을 상품 정보와 
            // 현재 로그인한 회원의 이메일 정보를 이용하여 
            // 장바구니에 상품을 담는 메소드를 호출함
            cartItemId = cartService.addCart(cartItemDto, email);
        } catch(Exception e){
            return new ResponseEntity<String>(e.getMessage(), HttpStatus.BAD_REQUEST);
        }

        // 결과값으로 생성된 장바구니 상품 아이디와 요청이 성공하였다는 HTTP 응답 상태 코드를 반환
        return new ResponseEntity<Long>(cartItemId, HttpStatus.OK);
    }
  
  
  
     itemDtl.html 에 javascript 함수 addCart() 작성
     
     
------------------------------------------------------------------------------------------------------------
  
   
 장바구니 조회하기
 
 CartDetailDto 작성하기
    쟁바구니 페이지에 전달할 데이터를 생성자의 파라미터로 설정함
 
 
 CartItemRepository 에
    장바구니 페이지에 전달할 CartDetailDto 리스트를 query 하나로 조회하는 JPQL문 작성
  
  
  CartDetailDto의 생성자를 이용하여 DTO를 반환할 때는 “new com.shop.dto.CartDetailDto(ci.id. i.itemNm,
  i.price. ci.count. im.imgUrl)” 처럼 new 키워드와 해당 DTO의 패키지.클래스명을 적음
  생성자의 파라미터 순서는 DTO 클래스에 명시한 순으로 넣어주어야 함
  
  @Query("select new com.tjoeun.shop.dto.CartDetailDto(ci.id, i.itemNm, i.price, ci.count, im.imgUrl) " +
        "from CartItem ci, ItemImg im " +
        "join ci.item i " +
        "where ci.cart.id = :cartId " +
        "and im.item.id = ci.item.id " +  <-- 장바구니에 담겨있는 상품의 대표 이미지만 가지고 오도록 조건문을 작성
        "and im.repimgYn = 'Y' " +        <-- 장바구니에 담겨있는 상품의 대표 이미지만 가지고 오도록 조건문을 작성
        "order by ci.regTime desc"
        )
    List<CartDetailDto> findCartDetailDtoList(@Param("cartId") Long cartId);
  
  
  CartService 에 getCartList(String email) 작성
  
   @Transactional(readOnly = true)
    public List<CartDetailDto> getCartList(String email){

        List<CartDetailDto> cartDetailDtoList = new ArrayList<>();

        Member member = memberRepository.findByEmail(email);
        
        // 현재 로그인한 회원의 장바구니 엔티티 조회
        Cart cart = cartRepository.findByMemberId(member.getId());
        
        // 장바구니에 상품을 한 번도 안 담았을 경우 장바구니 엔티티가 없으므로 빈 리스트 반환
        if(cart == null){
            return cartDetailDtoList;
        }

        // 장바구니에 담겨있는 상품 정보 조회
        cartDetailDtoList = cartItemRepository.findCartDetailDtoList(cart.getId());
        return cartDetailDtoList;
    }
   
   CartController 클래스에 장바구니 페이지로 이동할 수 있도록 @GetMapping("/cart") 추가하기
   
    @GetMapping("/cart")
    public String orderHist(Principal principal, Model model){
        // 현재 로그인한 사용자의 이메일 정보를 이용하여 장바구니에 담겨있는 상품 정보 조회  
        List<CartDetailDto> cartDetailList = cartService.getCartList(principal.getName());
        model.addAttribute("cartItems", cartDetailList);
        return "cart/cartList";
    }
   
    
    
    cartList.html 작성하기
	    
	• 장바구니 상품 선택 시 총 주문 금액 계산
	• x  버튼 클릭 시 장바구니에 담긴 상품 삭제
	• 장바구니 상품 수량 변경 시 상품 금액 계산
	• 장바구니 상품 수량 변경 시 장바구니에 담긴 상품 수량 업데이트
	• 장바구니상품주문하기
	• 장바구니상품전체선택


 <script th:inline="javascript">

        $(document).ready(function(){
        
            $("input[name=cartChkBox]").change( function(){
                // 주문할 상품을 체크하거나 해제할 경우 총 주문 금액을 구하는 함수 호출
                getOrderTotalPrice();
            });
        });

        // 총 주문 금액을 구하는 함수
        function getOrderTotalPrice(){
            let orderTotalPrice = 0;
            // 현재 체크된 장바구니 상품들의 가격과 수량을 곱해서 총 주문 금액 계산
            $("input[name=cartChkBox]:checked").each(function() {
                let cartItemId = $(this).val();
                let price = $("#price_" + cartItemId).attr("data-price");
                let count = $("#count_" + cartItemId).val();
                orderTotalPrice += price*count;
            });

            $("#orderTotalPrice").html(orderTotalPrice+' 원');
        }

        // 장바구니에 들어있는 상품의 수량을 변경 시 상품의 가격과 상품의 수량을 곱해서 상품 금액을 변경함
        // 변경된 총 주문 금액을 계산하기 위해서 마지막에 getOrderTotalPrice() 함수 호출
        function changeCount(obj){
            let count = obj.value;
            let cartItemId = obj.id.split('_')[1];
            let price = $("#price_" + cartItemId).data("price");
            let totalPrice = count*price;
            $("#totalPrice_" + cartItemId).html(totalPrice+" 원");
            getOrderTotalPrice();
            updateCartItemCount(cartItemId, count);
        }

        // 장바구니에 들어있는 전체 상품을 체크하거나 체크 해제하는 함수
        // 변경된 총 주문 금액을 계산하기 위해서 마지막에 getOrderTotalPrice ( ) 함수 호출
        function checkAll(){
            if($("#checkall").prop("checked")){
                $("input[name=cartChkBox]").prop("checked",true);
            }else{
                $("input[name=cartChkBox]").prop("checked",false);
            }
            getOrderTotalPrice();
        }

           ......
        

    </script>


  CartItem 클래스에 현재 장바구니에 담겨있는 수량을 변경하는 메소드 추가
     장바구니에서 상품의 수량을 변경할 경우 실시간으로 해당 회원의 장바구니 상품의 수량 변경
  
  public void updateCount(int count){
        this.count = count;
    }
  
  
  CartService 클래스에 장바구니 상품의 수량을 업데이트하는 메소드 추가
  
  
  
  @Transactional(readOnly = true)
    public boolean validateCartItem(Long cartItemId, String email){
        // 현재 로그인한 회원 조회
        Member curMember = memberRepository.findByEmail(email);
        
        CartItem cartItem = cartItemRepository.findById(cartItemId)
                .orElseThrow(EntityNotFoundException::new);
        // 장바구니 상품을 저장한 회원 조회                
        Member savedMember = cartItem.getCart().getMember();

        // 현재 로그인한 회원과 징바구니 상품을 저장한 회원이 다를 경우 false 반환
        if(!StringUtils.equals(curMember.getEmail(), savedMember.getEmail())){
            return false;
        }

        // 현재 로그인한 회원과 징바구니 상품을 저장한 회원이 같으면 true 반환
        return true;
    }


    // 장바구니 상품의 수량 업데이트
    public void updateCartItemCount(Long cartItemId, int count){
        CartItem cartItem = cartItemRepository.findById(cartItemId)
                .orElseThrow(EntityNotFoundException::new);

        cartItem.updateCount(count);
    }
  
  
    CartController 에...
    
    // HTTP 메소드에서 PATCH는 요청된 자원의 일부를 업데이트할 때 PATCH를 사용
    // 장바구니 상품의 수량만 업데이트하기 때문에 @PatchMapping을 사용
    @PatchMapping("/cartItem/{cartItemId}")
    @ResponseBody
    public ResponseEntity updateCartItem(@PathVariable("cartItemId") Long cartItemId, int count, Principal principal){

        // 장바구니에 담겨있는 상품의 개수를 0개 이하로 업데이트 요청을 할 때 
        // 에러 메시지를 담아서 ResponseEntity<String> 객체 반환함
        if(count <= 0){
            return new ResponseEntity<String>("최소 1개 이상은 담아야 합니다", HttpStatus.BAD_REQUEST);
            
        // 수정 권한 체크    
        } else if(!cartService.validateCartItem(cartItemId, principal.getName())){
            return new ResponseEntity<String>("수정 권한 없음", HttpStatus.FORBIDDEN);
        }

        // 장바구니 상품의 개수 업데이트
        cartService.updateCartItemCount(cartItemId, count);
        return new ResponseEntity<Long>(cartItemId, HttpStatus.OK);
    }
    
    
  cartList.html 에 updateCartItemCount 추가
  
  
  function updateCartItemCount(cartItemId, count){
            let token = $("meta[name='_csrf']").attr("content");
            let header = $("meta[name='_csrf_header']").attr("content");

            let url = "/cartItem/" + cartItemId+"?count=" + count;

            $.ajax({
                url      : url,
                type     : "PATCH",  <-- 부분 업데이트는 PATCH TYPE으로 설정
                beforeSend : function(xhr){
                    /* 데이터를 전송하기 전에 헤더에 csrf값을 설정 */
                    xhr.setRequestHeader(header, token);
                },
                dataType : "json",
                cache   : false,
                success  : function(result, status){
                    console.log("cartItem count update success");
                },
                error : function(jqXHR, status, error){

                	alert('로그인 후 이용해주세요');
                    location.href='/members/login';

                }
            });
        }
  
  
  CartService에 장바구니 상품 번호를 파라미터로 받아서 삭제하는 메소드 추가
  
  
      public void deleteCartItem(Long cartItemId) {
        CartItem cartItem = cartItemRepository.findById(cartItemId)
                .orElseThrow(EntityNotFoundException::new);
        cartItemRepository.delete(cartItem);
      }
  
  
  CartController 클래스에 장바구니 상품을 삭제하는 요청을 처리하는 메소드 추가
  
  // HTTP 메소드에서 DELETE의 경우 요청된 자원을 삭제할 때 사용
  // 장바구니 상품을 삭제하기 때문에 @DeleteMapping을 사용
  @DeleteMapping("/cartItem/{cartItemId}")
    @ResponseBody
    public ResponseEntity deleteCartItem(@PathVariable("cartItemId") Long cartItemId, Principal principal){

        // 수정 권한 체크
        if(!cartService.validateCartItem(cartItemId, principal.getName())){
            return new ResponseEntity<String>("수정 권한이 없습니다.", HttpStatus.FORBIDDEN);
        }

        // 해당 장바구니 상품 삭제
        cartService.deleteCartItem(cartItemId);

        return new ResponseEntity<Long>(cartItemId, HttpStatus.OK);
    }
  
  
  x 버튼 클릭 시 장바구니에 담긴 상품 삭제
    cartList.html 에 deleteCartItem 추가
  
  function deleteCartItem(obj){
            let cartItemId = obj.dataset.id;
            let token = $("meta[name='_csrf']").attr("content");
            let header = $("meta[name='_csrf_header']").attr("content");

            let url = "/cartItem/" + cartItemId;

            $.ajax({
                url      : url,
                type     : "DELETE",  <-- 장바구니 상품을 삭제하는 경우에는 DELETE TYPE을 사용
                beforeSend : function(xhr){
                    /* 데이터를 전송하기 전에 헤더에 csrf값을 설정 */
                    xhr.setRequestHeader(header, token);
                },
                dataType : "json",
                cache   : false,
                success  : function(result, status){
                    // 삭제 요청이 정상적으로 처리되면 장바구니 페이지를 새로고침함
                    location.href='/cart';
                },
                error : function(jqXHR, status, error){

                	alert('로그인 후 이용해주세요');
                    location.href='/members/login';

                }
            });
        }
  
  
------------------------------------------------------------------------------------------------------------
  
   
 장바구니에 담은 상품 주문하기
 
 
 장바구니 목록 중 체크박스가 선택된 상품을 주문함
 장바구니에서 주문을 하면 여러 개의 상품을 하나의 주문에 담을 수 있고
 주문한 상품은 장바구니에서 삭제함
 
 
 CartOrderDto 클래스 작성하기
 
 
 public class CartOrderDto {

    private Long cartItemId;
    
    // 장바구니에서 여러 개의 상품을 주문하기에 
    // CartOrderDto 클래스가 자기 자신을 List로 선언함
    private List<CartOrderDto> cartOrderDtoList;

}
 
 OrderService 클래스에 장바구니에서 주문할 상품 데이터를 전달받아서 주문을 생성하는 메소드 작성하기
 
 
 public Long orders(List<OrderDto> orderDtoList, String email){

        Member member = memberRepository.findByEmail(email);
        List<OrderItem> orderItemList = new ArrayList<>();

        // 주문할 상품 리스트 생성하기
        for (OrderDto orderDto : orderDtoList) {
            Item item = itemRepository.findById(orderDto.getItemId())
                                      .orElseThrow(EntityNotFoundException::new);

            OrderItem orderItem = OrderItem.createOrderItem(item, orderDto.getCount());
            orderItemList.add(orderItem);
        }

        // 현재 로그인한 회원과 주문 상품 목록을 이용하여 주문 엔티티를 생성함
        Order order = Order.createOrder(member, orderItemList);
        
        // 주문 데이터 저장
        orderRepository.save(order);

        return order.getId();
    }
 
 
  CartService 클래스에서는 주문 로직으로 전달할 orderDto 리스트 생성 및 주문 메소드 호출하기
  주문한 상품은 장바구니에서 제거하는 메소드 작성함
 
 
  CartService 에 orderCartItem() 메소드 작성하기
  
  public Long orderCartItem(List<CartOrderDto> cartOrderDtoList, String email){
        List<OrderDto> orderDtoList = new ArrayList<>();

        // 장바구니 페이지에서 전달받은 주문 상품 번호를 이용하여 주문 로직으로 전달할 orderDto 객체를 생성함
        for (CartOrderDto cartOrderDto : cartOrderDtoList) {
            CartItem cartItem = cartItemRepository
                            .findById(cartOrderDto.getCartItemId())
                            .orElseThrow(EntityNotFoundException::new);

            OrderDto orderDto = new OrderDto();
            orderDto.setItemId(cartItem.getItem().getId());
            orderDto.setCount(cartItem.getCount());
            orderDtoList.add(orderDto);
        }

        // 장바구니에 담은 상품을 주문하도록 주문 메소드 호출하기
        Long orderId = orderService.orders(orderDtoList, email);
        
        // 주문한 상품들을 징바구니에서 제거
        for (CartOrderDto cartOrderDto : cartOrderDtoList) {
            CartItem cartItem = cartItemRepository
                            .findById(cartOrderDto.getCartItemId())
                            .orElseThrow(EntityNotFoundException::new);
            cartItemRepository.delete(cartItem);
        }

        return orderId;
    }
  
 
   CartController 클래스에 장바구니 상품의 수량을 업데이트하는 요청을 처리하는 메소드 작성하기
   
   @PostMapping("/cart/orders")
    @ResponseBody
    public ResponseEntity orderCartItem(@RequestBody CartOrderDto cartOrderDto, Principal principal){

        List<CartOrderDto> cartOrderDtoList = cartOrderDto.getCartOrderDtoList();

        // 주문할 상품을 선택하지 않았는지 체크
        if(cartOrderDtoList == null || cartOrderDtoList.size() == 0){
            return new ResponseEntity<String>("주문할 상품을 선택해주세요", HttpStatus.FORBIDDEN);
        }

        // 주문 권한 체크
        for (CartOrderDto cartOrder : cartOrderDtoList) {
            if(!cartService.validateCartItem(cartOrder.getCartItemId(), principal.getName())){
                return new ResponseEntity<String>("주문 권한이 없습니다.", HttpStatus.FORBIDDEN);
            }
        }

        // 주문 로직 호출 결과 생성된 주문 번호를 반환 받음
        Long orderId = cartService.orderCartItem(cartOrderDtoList, principal.getName());
        
        // 생성된 주문 번호와 요청이 성공했다는 HTTP 응답 상태 코드를 반환함
        return new ResponseEntity<Long>(orderId, HttpStatus.OK);
    }
   
   
    cartList.html 에 orders 추가
 
 
         function orders(){
            let token = $("meta[name='_csrf']").attr("content");
            let header = $("meta[name='_csrf_header']").attr("content");

            let url = "/cart/orders";

            let dataList = new Array();
            let paramData = new Object();

            // 체크된 장바구니 상품 아이디를 전달하기 위해서 dataList 에 
            // 장바구니 상품 아이디를 객체로 만들어서 저장함
            $("input[name=cartChkBox]:checked").each(function() {
                let cartItemId = $(this).val();
                let data = new Object();
                data["cartItemId"] = cartItemId;
                dataList.push(data);
            });

            // 장바구니 상품 아이디를 저장하고 있는 dataList 를 paramData 객체에 추가
            paramData['cartOrderDtoList'] = dataList;

            let param = JSON.stringify(paramData);

            $.ajax({
                url      : url,
                type     : "POST",
                contentType : "application/json",
                data     : param,
                beforeSend : function(xhr){
                    /* 데이터를 전송하기 전에 헤더에 csrf값을 설정 */
                    xhr.setRequestHeader(header, token);
                },
                dataType : "json",
                cache   : false,
                success  : function(result, status){
                    alert("주문이 완료 되었습니다.");
                    
                    // 주문 요청 결과 성공하였다면 구매이력 페이지로 이동
                    location.href='/orders';
                },
                error : function(jqXHR, status, error){

                	alert('로그인 후 이용해주세요');
                    location.href='/members/login';

                }
            });
        }

 
 
 
 
 
 
 
 


